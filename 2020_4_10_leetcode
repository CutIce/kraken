// #151. 翻转字符串里的单词
class Solution {
public:
    string reverseWords(string s) {
        int n=s.size();int l=0,r=0;int i=0;
        bool flag=false;
        string res="",tem;
        while (i<n){
        while (s[i]==' '&&i<n){++i;}
        if (i>=n) break;
        l=i;
        while (s[i]!=' '&&i<n){++i;}
        r=i;
        tem=s.substr(l,r-l);
        res.insert(0,tem);
        res.insert(0," ");
        }
        res.replace(0,1,"");
        return res;    
    }
};

// # 118. 杨辉三角
class Solution {
public:
    vector<vector<int>> generate(int n) {
        vector <vector<int>> res(n);
        for (int i=0;i<n;++i){
            res[i].resize(i+1,1);
            for (int j=1;j<i;++j){
                res[i][j]=res[i-1][j-1]+res[i-1][j];
            }
        }
        return res;
    }
}; 

// #  88. 合并两个有序数组
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector tem(nums1);
        int i=0;int l=0,r=0;
        while (i<m+n){
            if (l==m&&r<n) {nums1[i]=nums2[r];++r,++i;}
            else if (r==n&&l<m) {nums1[i]=tem[l];++l,++i;}
            else if (tem[l]<nums2[r]) {nums1[i]=tem[l];++l,++i;}
            else {nums1[i]=nums2[r];++r,++i;}
        }
        if (m!=0&&n!=0)
        nums1[m+n-1]=max(tem[m-1],nums2[n-1]);
    }
};